{"searchDocs":[{"title":"Client","type":0,"sectionRef":"#","url":"/PakNet/api/Client","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Client","url":"/PakNet/api/Client#functions","content":" ","version":null,"tagName":"h2"},{"title":"FireServer​","type":1,"pageTitle":"Client","url":"/PakNet/api/Client#FireServer","content":"&lt;/&gt; Client:FireServer( args: ...any-- The arguments tuple specified by the params schema ) → ()   ","version":null,"tagName":"h3"},{"title":"FireServerUnreliable​","type":1,"pageTitle":"Client","url":"/PakNet/api/Client#FireServerUnreliable","content":"&lt;/&gt; Client:FireServerUnreliable( args: ...any-- The arguments tuple specified by the params schema ) → ()  Unreliable This is the UnreliableRemoteEvent version of Client:FireServer. Unreliable variants can have reduced network traffic, at the cost of having a payload limit of 900 bytes, being unordered, and not guaranteed to be recieved. This makes them good for non-essential events such as those for VFX, or constantly updating data that needs to be replicated.  ","version":null,"tagName":"h3"},{"title":"InvokeServer​","type":1,"pageTitle":"Client","url":"/PakNet/api/Client#InvokeServer","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Client:InvokeServer( args: ..any-- The arguments tuple specified by the params schema ) → ...any-- The return tuple specified by the returns schema, or nil if it times out  WARNING If the server never returns anything, the thread will be left yielding forever unless a timeout is specified.  ","version":null,"tagName":"h3"},{"title":"InvokeServerAsync​","type":1,"pageTitle":"Client","url":"/PakNet/api/Client#InvokeServerAsync","content":"&lt;/&gt; Client:InvokeServerAsync( args: ..any-- The arguments tuple specified by the params schema ) → Promise  Asynchronous variant of InvokeServer that does not block the calling thread, and instead returns a Promise WARNING Without an timeout set, the promise can yield forever if the server never returns anything. You could use the Promise:timeout(n) method as well, just make sure to do this everywhere if you are removing the timeout. You may want to set timeout very high as opposed to removing it, as without it the promise will raise a warning after 15 seconds. ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/PakNet/docs/Installation","content":"","keywords":"","version":"Next"},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/PakNet/docs/Installation#wally","content":" Get the latest version of PakNet from wally.run and add it to your wally.toml  You will need to use wally-package-types to fix the types  ","version":"Next","tagName":"h2"},{"title":"Stand-alone​","type":1,"pageTitle":"Installation","url":"/PakNet/docs/Installation#stand-alone","content":" Download the latest PakNet.rbxm from releases and insert it into ReplicatedStorage ","version":"Next","tagName":"h2"},{"title":"Welcome to PakNet","type":0,"sectionRef":"#","url":"/PakNet/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Why PakNet?​","type":1,"pageTitle":"Welcome to PakNet","url":"/PakNet/docs/intro#why-paknet","content":" PakNet stands out from other networking libraries by offering greater versatility in Schema construction, enabling support for complex data structures with minimal overhead. Unlike alternatives that prioritize raw speed, PakNet's serialization engine — powered by Pack — focuses on reducing bandwidth usage. This is crucial for scaling Roblox games, as the platform enforces a soft transfer limit of 50KiB/s, making bandwidth efficiency more important than sheer serialization speed.  Many networking libraries fall into the &quot;one remote event&quot; trap, where only a single RemoteEvent or RemoteFunction is used, with an identifier included in every packet. This approach wastes bandwidth, as each packet requires additional bytes for the identifier. PakNet avoids this inefficiency by allowing RakNet (Roblox’s underlying network engine) to handle message routing directly, eliminating unnecessary overhead.  Security is another area where PakNet excels. Each remote instance is hashed using SHA-224, making it significantly harder for exploiters using tools like SimpleSpy to reverse-engineer a game's remotes. Additionally, PakNet provides built-in server-side security signals — such as alerts for packet deserialization failures (often caused by buffer tampering) and triggers for server-side rate limits — giving developers better tools to detect and respond to exploit attempts.  ","version":"Next","tagName":"h2"},{"title":"Shortcuts​","type":1,"pageTitle":"Welcome to PakNet","url":"/PakNet/docs/intro#shortcuts","content":" Installation\tUsage\tAPI Reference ","version":"Next","tagName":"h2"},{"title":"RemoteSettings","type":0,"sectionRef":"#","url":"/PakNet/api/RemoteSettings","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#types","content":" ","version":null,"tagName":"h2"},{"title":"RemoteType​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#RemoteType","content":"&lt;/&gt; type RemoteType = &quot;f&quot; | &quot;r&quot; | &quot;u&quot; | &quot;fr&quot; | &quot;fu&quot; | &quot;fru&quot; Indicates what type(s) of remote event this Remote will need as a string literal f : function - enables returns and invoke methods r : reliable - a standard remote event, enables the basic methods u : unreliable - an unreliable remote event, enables unreliable variants of the basic methods Combinations of these letters activate each mode. The literal is written in alphabetical order. WARNING Unreliable Remotes have a payload limit of 900 bytes. Unreliables are best used for ephemeral events including effects that are only relevant for a short time, or for replicating continuously changing data. These events are not resent if they are lost and they do not wait for previously fired events to arrive before being processed, potentially resulting in reduced latency and network traffic.  ","version":null,"tagName":"h3"},{"title":"RateLimitSettings​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#RateLimitSettings","content":"&lt;/&gt; interface RateLimitSettings { global: boolean?-- When true - the rate limit applies for all players, otherwise is per player. Defaults to true. limit: number-- Maximum number of entrances in the window window: nubmer-- How many seconds the window lasts } Applies a sliding-window rate limit to the Remote. What this means is that if limit number of entrances have been made within the last window seconds, The action will be rate limited and dropped. When checking, actions from over window seconds ago will be ignored, hence it is a sliding-window, instead of a fixed window that resets after a number of seconds. This is applied on both the server (incoming traffic) and client (outgoing traffic). The signal onRateLimited for Server or Client remotes will be fired when the ratelimit is reached. If the server rate limit is triggered, that usually means the client is exploiting, as they should not be able to get past their local rate limit otherwise. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#properties","content":" ","version":null,"tagName":"h2"},{"title":"params​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#params","content":"&lt;/&gt; RemoteSettings.params: Schema  Pack schema defining the structure of the packet  ","version":null,"tagName":"h3"},{"title":"returns​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#returns","content":"&lt;/&gt; RemoteSettings.returns: Schema  Pack schema defining the strucutre of the return when invoking the packet, if applicable  ","version":null,"tagName":"h3"},{"title":"remoteType​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#remoteType","content":"&lt;/&gt; RemoteSettings.remoteType: RemoteType   ","version":null,"tagName":"h3"},{"title":"rateLimit​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#rateLimit","content":"&lt;/&gt; RemoteSettings.rateLimit: RateLimitSetting?   ","version":null,"tagName":"h3"},{"title":"timeout​","type":1,"pageTitle":"RemoteSettings","url":"/PakNet/api/RemoteSettings#timeout","content":"&lt;/&gt; RemoteSettings.timeout: number?  ","version":null,"tagName":"h3"},{"title":"PakNet","type":0,"sectionRef":"#","url":"/PakNet/api/PakNet","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"PakNet","url":"/PakNet/api/PakNet#functions","content":" ","version":null,"tagName":"h2"},{"title":"Mount​","type":1,"pageTitle":"PakNet","url":"/PakNet/api/PakNet#Mount","content":"&lt;/&gt; PakNet:Mount( file: Instance , RemoteTable: {[string]: RemoteSetting} ) → {[string]: Server | Client} Mounts a namespace (RemoteTable) to a file, with the file usually being the ModuleScript calling this method. WARNING Do not mount multiple namespaces to the same file. This can cause name collisions and break everything — even if the namespaces don't overlap. Organizational Tips Typically, you'll mount the remote directly to the current script. If you want to create multiple namespaces within a single script for better organization, create folders under the module for each namespace and mount to those.  ","version":null,"tagName":"h3"},{"title":"DefineRemote​","type":1,"pageTitle":"PakNet","url":"/PakNet/api/PakNet#DefineRemote","content":"&lt;/&gt; PakNet:DefineRemote(settings:: RemoteSettings) → Server | Client Defines a remote from a RemoteSettings table.  ","version":null,"tagName":"h3"},{"title":"Schema​","type":1,"pageTitle":"PakNet","url":"/PakNet/api/PakNet#Schema","content":"&lt;/&gt; PakNet:Schema(...: Datatype ) → Schema  Defines a Schema from the provided datatypes. This supports tuples, however due to luau limitations you will need to manually annotate the type. -- The type of this schema will implicitly be infered as CFrame PakNet:Schema(PakNet.CFrame) -- For tuples, you must explicitly annotate the type of the schema using PakNet.Schema&lt;...&gt;. -- The luau type solver can only infer the first argument. PakNet:Schema(PakNet.CFrame, PakNet.Vector3) :: PakNet.Schema&lt;CFrame, Vector3&gt;   ","version":null,"tagName":"h3"},{"title":"LoadGlobalSignal​","type":1,"pageTitle":"PakNet","url":"/PakNet/api/PakNet#LoadGlobalSignal","content":"&lt;/&gt; PakNet:LoadGlobalSignal() → (identifier: string) → Signal  The global signal library provides a way to create and manage signals that can be accessed across multiple scripts within the same execution environment (server or client). This allows scripts to communicate without direct references. Global signals are retrieved using a string identifier, making it easy to share events across scripts. However, they do not persist between actors, meaning signals created in one actor are not accessible in another. Using the global signal library is optional. If you don’t need it, you don’t have to use it. It’s useful for loosely coupling scripts, centralizing event handling, and managing shared state without relying on direct references. -- network.luau local namespace = PakNet:Mount(...) namespace.Signal = PakNet:LoadGlobalSignal() return namespace -- example1.server.luau local network = require(path.to.network) local signal = network.Signal(&quot;Example&quot;) signal:Fire(&quot;Hello World!&quot;) -- example2.server.luau local network = require(path.to.network) local signal = network.Signal(&quot;Example&quot;) signal:Connect(function(...) print(...) -- &gt;&gt;&gt; Hello World! end)  ","version":null,"tagName":"h3"},{"title":"Server","type":0,"sectionRef":"#","url":"/PakNet/api/Server","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#properties","content":" ","version":null,"tagName":"h2"},{"title":"onEvent​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#onEvent","content":"&lt;/&gt; Server.onEvent: Signal  A signal that fires when a Remote is fired with FireServer or FireServerUnreliable from the client if self._events.r or self._events.u then self.onEvent = LemonSignal.new() end  ","version":null,"tagName":"h3"},{"title":"onRateLimited​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#onRateLimited","content":"&lt;/&gt; Server.onRateLimited: Signal  A signal that fires when the server-side ratelimit rejects a packet. Sends the player that tripped the ratelimit (even if global). This can be a sign of tampering, but there may still be cases where flucuations in network latency cause false positives. The server rate limit is adjusted to be slightly less strict than the client rate limit to compensate for this.  ","version":null,"tagName":"h3"},{"title":"onParseError​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#onParseError","content":"&lt;/&gt; Server.onParseError: Signal  A signal that fires when parsing an incoming packet errors. Sends the player that caused the parse error, followed by the error. If this happens, it means either a client is tampering with something or you have an issue with your remotes on the client side. I would recommend ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#functions","content":" ","version":null,"tagName":"h2"},{"title":"Fire​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#Fire","content":"&lt;/&gt; Server:Fire( to: Player , args: ...any-- The arguments tuple specified by the params schema ) → ()   ","version":null,"tagName":"h3"},{"title":"FireAll​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireAll","content":"&lt;/&gt; Server:FireAll( args: ...any-- The arguments tuple specified by the params schema ) → () Fires to all players in the server  ","version":null,"tagName":"h3"},{"title":"FireList​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireList","content":"&lt;/&gt; Server:FireList( players: {Player },-- The list of players to send to args: ...any-- The arguments tuple specified by the params schema ) → ()   ","version":null,"tagName":"h3"},{"title":"FireExcept​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireExcept","content":"&lt;/&gt; Server:FireExcept( except: {Player },-- The list of players not to send to args: ...any-- The arguments tuple specified by the params schema ) → () Fires to all players except those included in the except table  ","version":null,"tagName":"h3"},{"title":"FireUnreliable​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireUnreliable","content":"&lt;/&gt; Server:FireUnreliable( to: Player , args: ...any-- The arguments tuple specified by the params schema ) → ()  Unreliable This is the UnreliableRemoteEvent version of Server:Fire. Unreliable variants can have reduced network traffic, at the cost of having a payload limit of 900 bytes, being unordered, and not guaranteed to be recieved. This makes them good for non-essential events such as those for VFX, or constantly updating data that needs to be replicated.  ","version":null,"tagName":"h3"},{"title":"FireAllUnreliable​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireAllUnreliable","content":"&lt;/&gt; Server:FireAllUnreliable( args: ...any-- The arguments tuple specified by the params schema ) → () Fires to all players in the server Unreliable This is the UnreliableRemoteEvent version of [Sever:FireAll]. Unreliable variants can have reduced network traffic, at the cost of having a payload limit of 900 bytes, being unordered, and not guaranteed to be recieved. This makes them good for non-essential events such as those for VFX, or constantly updating data that needs to be replicated.  ","version":null,"tagName":"h3"},{"title":"FireListUnreliable​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireListUnreliable","content":"&lt;/&gt; Server:FireListUnreliable( players: {Player },-- The list of players to send to args: ...any-- The arguments tuple specified by the params schema ) → ()  Unreliable This is the UnreliableRemoteEvent version of Server:FireList. Unreliable variants can have reduced network traffic, at the cost of having a payload limit of 900 bytes, being unordered, and not guaranteed to be recieved. This makes them good for non-essential events such as those for VFX, or constantly updating data that needs to be replicated.  ","version":null,"tagName":"h3"},{"title":"FireExceptUnreliable​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#FireExceptUnreliable","content":"&lt;/&gt; Server:FireExceptUnreliable( except: {Player },-- The list of players not to send to args: ...any-- The arguments tuple specified by the params schema ) → () Fires to all players except those included in the except table Unreliable This is the UnreliableRemoteEvent version of Server:FireExcept. Unreliable variants can have reduced network traffic, at the cost of having a payload limit of 900 bytes, being unordered, and not guaranteed to be recieved. This makes them good for non-essential events such as those for VFX, or constantly updating data that needs to be replicated.  ","version":null,"tagName":"h3"},{"title":"Invoke​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#Invoke","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Server:Invoke( to: Player , args: ..any-- The arguments tuple specified by the params schema ) → ...any-- The return tuple specified by the returns schema, or nil if it times out  DANGER Invoking the client from the server should always be done with a timeout set in the remote settings. In the event an exploiter modifies the client invoke callback to never return, not having a callback will cause that thread to yield forever on the server, piling up in memory. Many people will tell you never to invoke the client from the server in general, but there are valid use cases and its up to you if you want to use something or not.  ","version":null,"tagName":"h3"},{"title":"InvokeAsync​","type":1,"pageTitle":"Server","url":"/PakNet/api/Server#InvokeAsync","content":"&lt;/&gt; Server:InvokeAsync( to: Player , args: ..any-- The arguments tuple specified by the params schema ) → Promise  Asynchronous variant of Invoke that does not block the calling thread, and instead returns a Promise DANGER Without an timeout set, the promise can yield forever. You could use the Promise:timeout(n) method as well, just make sure to do this everywhere if you are removing the timeout. You may want to set timeout very high as opposed to removing it, as without it the promise will raise a warning after 15 seconds. ","version":null,"tagName":"h3"},{"title":"Usage","type":0,"sectionRef":"#","url":"/PakNet/docs/Usage","content":"","keywords":"","version":"Next"},{"title":"Creating Remotes​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#creating-remotes","content":" To create remotes, you'll need to use the PakNet:Mount function. This function mounts a remote namespace, where each remote is a key-value pair that represents a remote definition.  PakNet:Mount(file: Instance, namespace: RemoteTable)   file: The Instance where remote instances will be created (usually script).namespace: A table that holds the remote definitions.  warning Do not mount multiple namespaces to the same file. This can cause name collisions and break everything — even if the namespaces don't overlap.  ","version":"Next","tagName":"h3"},{"title":"Organizational Tips:​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#organizational-tips","content":" Typically, you'll mount the remote directly to the current script.If you want to create multiple namespaces within a single script for better organization, create folders under the module for each namespace and mount to those.  ","version":"Next","tagName":"h3"},{"title":"Defining Remotes​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#defining-remotes","content":" A remote table is essentially a map where each key is the remote name, and the value is the remote's definition. To define a remote, use:  PakNet:DefineRemote(settings: RemoteSettings)   The RemoteSettings is a dictionary with the following fields:  params (required): A PakNet schema that defines the parameters for the remote. returns (required for remote functions only): A PakNet schema that defines the return values for the remote function. remoteType (required): Specifies the type of remote. It can be any combination of the following: &quot;f&quot;: RemoteFunction&quot;r&quot;: RemoteEvent&quot;u&quot;: UnreliableRemoteEventCombinations like &quot;fr&quot;, &quot;fu&quot;, &quot;ru&quot;, and &quot;fru&quot; can also be used for remotes that have multiple types (e.g., a remote that is both a RemoteFunction and a RemoteEvent, also note that it is always written in alphabetical order). rateLimit (optional): A table that specifies rate limiting for the remote. global: Boolean indicating whether the rate limit applies globally or per player.limit: The maximum number of requests allowed within a specified window.window: The duration in seconds that defines the rate limit window. timeout (optional): A number specifying the timeout duration (in seconds) for remote functions.  networkExample.luau local PakNet = require(path.to.PakNet) -- We will mount this namespace on the current script local namespace = PakNet:Mount(script, { -- The name of the remote is the key, and the value is a remote configuration, created with PakNet:DefineRemote() SomeRemoteEvent = PakNet:DefineRemote({ -- params is a schema defining how to read and write the packet. -- PakNet:Schema is used the same as Pack:Define params = PakNet:Schema(PakNet.String16), -- remoteType is a string telling PakNet what instances we need for the remote -- If it contains &quot;r&quot;, a RemoteEvent will be created remoteType = &quot;r&quot;, }), SomeUnreliableEvent = PakNet:DefineRemote({ -- If we are using a tuple schema, we have to assert the type due to luau being unable to capture the generic pack -- Hovering over the datatype will show you what the type is defined at if you are unsure params = PakNet:Schema(PakNet.Float64, PakNet.Vector3) :: PakNet.Schema&lt;number, vector&gt;, -- If remoteType contains &quot;u&quot;, an UnreliableRemoteEvent will be created remoteType = &quot;u&quot;, -- We can attach a ratelimit to our remote, to prevent it being spammed rateLimit = { limit = 60, -- Allows 60 requests window = 3, -- per 3 seconds }, }), SomeRemoteFunction = PakNet:DefineRemote({ params = PakNet:Schema(PakNet.Array(PakNet.Double)), -- When we have a remote function, we have to specify the return schema as well returns = PakNet:Schema(PakNet.UInt), -- If remoteType contains &quot;f&quot;, a RemoteFunction will be created remoteType = &quot;f&quot;, -- We can set a timeout for remote functions, after which requests will be cancelled and nil will be returned timeout = 5, }), SomeEverythingEvent = PakNet:DefineRemote({ -- Heres an example of a more complex schema params = PakNet:Schema(PakNet.Dictionary({ Name = PakNet.String16, Level = PakNet.UByte, CFrame = PakNet.CFrame, Buildings = PakNet.Map(PakNet.Vector3, PakNet.Instance), })), returns = PakNet:Schema(PakNet.Array(PakNet.nullable(PakNet.Double))), -- We can combine remote types, but they must be in alphabetical order -- For example you could also use &quot;fr&quot; &quot;fu&quot; or &quot;ru&quot; remoteType = &quot;fru&quot;, rateLimit = { limit = 10, -- Allows 10 requests window = 1, -- per second }, timeout = 15, }), }) -- You can pass through the global signal function, if you find that useful -- Nice if you have a centralized network module, rarther than many separate namespaces namespace.Signal = PakNet:LoadGlobalSignal() return namespace   tip When defining a tuple Schema (one with multiple arguments), you have to assert the type as PakNet.Schema&lt;...&gt; When you have complicated data structures, it can be annoying to convert them into standard types. You can copy the definition inside the function and surround it in typeof() instead of writing it out with types as well. params = PakNet:Schema(PakNet.Dictionary({ Name = PakNet.String16, Level = PakNet.UByte, }, PakNet.Int)) :: PakNet.Schema&lt;typeof(PakNet.Dictionary({ Name = PakNet.String16, Level = PakNet.UByte, }), typeof(PakNet.Int)&gt;   How you organize namespaces is up to you. You might want to create a centralized network module with all remotes inside it, or you might want to create multiple network modules for different things.  ","version":"Next","tagName":"h3"},{"title":"Using Remotes​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#using-remotes","content":" Remotes in PakNet have a unified API that combines both server and client functionality. Some changes have been made to the API to simplify naming conventions and add new features.  ","version":"Next","tagName":"h2"},{"title":"Key Changes:​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#key-changes","content":" Unified API: Server and client remote methods are combined. For example: FireClient is now just Fire.OnServerEvent is now OnEvent. The names on the client side remain the same. New Features: Server-only methods: FireList and FireExcept: Variants of the Fire method.OnParseError: Fires when an incoming packet fails to deserialize. Async Methods: Both server and client have: InvokeAsync (on the client, it's called InvokeServerAsync): A non-blocking version of Invoke that returns a Promise. Rate Limiting: OnRateLimited event: Triggers when a player is rate-limited, and the server will receive the player object. Unreliable Variants: All Fire methods have unreliable variants that use a UnreliableRemoteEvent instead of a RemoteEvent.  ","version":"Next","tagName":"h3"},{"title":"Access Based on Remote Type:​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#access-based-on-remote-type","content":" The parts of the API you can use depend on whether you’re on the server or client and the remote's type. Here’s a breakdown:  &quot;f&quot; (Functions): Unlocks OnInvoke, OnClientInvoke, Invoke, InvokeAsync, InvokeServer, and InvokeServerAsync. &quot;r&quot; (Remote): Unlocks OnEvent, OnClientEvent, Fire, FireAll, FireList, FireExcept, and FireServer. &quot;u&quot; (Unreliable): Unlocks OnEvent, OnClientEvent, FireUnreliable, FireAllUnreliable, FireListUnreliable, FireExceptUnreliable, and FireServerUnreliable.  ","version":"Next","tagName":"h3"},{"title":"Common Access:​","type":1,"pageTitle":"Usage","url":"/PakNet/docs/Usage#common-access","content":" Server always has access to the OnParseError event.Both server and client always have access to the OnRateLimited event and the ClassName property (which indicates whether the current context is &quot;Server&quot; or &quot;Client&quot;).  ClientExample.luau local network = require(game:GetService(&quot;ReplicatedStorage&quot;):WaitForChild(&quot;networkExample&quot;)) network.SomeRemoteEvent:FireServer(&quot;Hello World!&quot;) -- Send SomeUnreliableEvent faster than the rate limit network.SomeUnreliableEvent.OnRateLimited:Connect(function() print(&quot;Rate Limited&quot;) -- &gt;&gt;&gt; Rate Limited (x40) end) for i = 1, 100 do network.SomeUnreliableEvent:FireServerUnreliable(i, Vector3.new(i, i, i)) end print(network.SomeRemoteFunction:InvokeServer({ Name = &quot;Bob&quot;, Level = 9001, CFrame = CFrame.identity, Buildings = {}, })) -- &gt;&gt;&gt; 9001   ServerExample.luau local network = require(game:GetService(&quot;ReplicatedStorage&quot;):WaitForChild(&quot;networkExample&quot;)) -- A big benefit of schemas is that you get proper typings, so message will default to string in this example network.SomeRemoteEvent.OnEvent:Connect(function(message) print(message) -- &gt;&gt;&gt; Hello World! end) network.SomeUnreliableEvent.OnEvent:Connect(function(num, vector) print(num) -- The client ratelimit will stop it at 60 -- &gt;&gt;&gt; 1 ... 60 end) network.SomeRemoteFunction.OnInvoke = function(player, data) print(data) --[[ &gt;&gt;&gt;{ [&quot;Buildings&quot;] = {}, [&quot;CFrame&quot;] = 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, [&quot;Level&quot;] = 9001, [&quot;Name&quot;] = &quot;Bob&quot; } ]] return data.Level end  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}