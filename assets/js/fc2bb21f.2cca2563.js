"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[523],{7027:e=>{e.exports=JSON.parse('{"functions":[{"name":"Mount","desc":"Mounts a namespace (RemoteTable) to a file, with the file usually being the ModuleScript calling this method.\\n\\n:::warning\\nDo not mount multiple namespaces to the same file. This can cause name collisions and break everything \u2014 even if the namespaces don\'t overlap.\\n:::\\n\\n:::tip[Organizational Tips]\\n- Typically, you\'ll mount the remote directly to the current script.\\n- If you want to create multiple namespaces within a single script for better organization, create folders under the module for each namespace and mount to those.\\n:::","params":[{"name":"file","desc":"","lua_type":"Instance"},{"name":"RemoteTable","desc":"","lua_type":"{[string]: RemoteSetting}"}],"returns":[{"desc":"","lua_type":"{[string]: Server | Client}"}],"function_type":"method","source":{"line":51,"path":"src/init.luau"}},{"name":"DefineRemote","desc":"Defines a remote from a RemoteSettings table.","params":[{"name":"settings:","desc":"","lua_type":"RemoteSettings"}],"returns":[{"desc":"","lua_type":"Server | Client"}],"function_type":"method","source":{"line":95,"path":"src/init.luau"}},{"name":"Schema","desc":"Defines a Schema from the provided datatypes.  \\nThis supports tuples, however due to luau limitations you will need to manually annotate the type.\\n\\n```lua\\n-- The type of this schema will implicitly be infered as CFrame\\nPakNet:Schema(PakNet.CFrame)\\n\\n-- For tuples, you must explicitly annotate the type of the schema using PakNet.Schema<...>. \\n-- The luau type solver can only infer the first argument.\\nPakNet:Schema(PakNet.CFrame, PakNet.Vector3) :: PakNet.Schema<CFrame, Vector3>\\n```","params":[{"name":"...","desc":"","lua_type":"Datatype"}],"returns":[{"desc":"","lua_type":"Schema"}],"function_type":"method","external_types":[{"name":"Datatype","url":"https://isoopod.github.io/Pack/docs/Datatypes/Primitives"}],"source":{"line":119,"path":"src/init.luau"}},{"name":"LoadGlobalSignal","desc":"The global signal library provides a way to create and manage signals that can be accessed across multiple scripts within the same execution environment (server or client). This allows scripts to communicate without direct references.  \\n\\nGlobal signals are retrieved using a **string identifier**, making it easy to share events across scripts. However, **they do not persist between actors**, meaning signals created in one actor are not accessible in another.  \\n\\nUsing the global signal library is **optional**. If you don\u2019t need it, you don\u2019t have to use it. It\u2019s useful for loosely coupling scripts, centralizing event handling, and managing shared state without relying on direct references.\\n\\n```lua\\n-- network.luau\\nlocal namespace = PakNet:Mount(...)\\n\\nnamespace.Signal = PakNet:LoadGlobalSignal()\\n\\nreturn namespace\\n```\\n\\n```lua\\n-- example1.server.luau\\nlocal network = require(path.to.network)\\n\\nlocal signal = network.Signal(\\"Example\\")\\nsignal:Fire(\\"Hello World!\\")\\n```\\n\\n```lua\\n-- example2.server.luau\\nlocal network = require(path.to.network)\\n\\nlocal signal = network.Signal(\\"Example\\")\\nsignal:Connect(function(...)\\n\\tprint(...) -- >>> Hello World!\\nend)\\n```","params":[],"returns":[{"desc":"","lua_type":"(identifier: string) -> Signal"}],"function_type":"method","source":{"line":165,"path":"src/init.luau"}}],"properties":[],"types":[],"name":"PakNet","desc":"Main class for PakNet, used to create Remotes and houses some utilities","source":{"line":31,"path":"src/init.luau"}}')}}]);